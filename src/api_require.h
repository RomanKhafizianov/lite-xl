#ifndef API_REQUIRE_H
#define API_REQUIRE_H
/**
This file contains the function api_require that
returns a function pointer with it's corresponding name.

This file is automatically generated. DO NOT MODIFY.
**/

// #!/bin/bash
// 
// ##### CONFIG
// 
// # symbols to ignore
// IGNORE_SYM='luaL_pushmodule\|luaL_openlib'
// 
// ##### CONFIG
// 
// 
// # https://stackoverflow.com/a/13062682
// uncomment() {
//   [ $# -eq 2 ] && arg="$1" || arg=""
//   eval file="\$$#"
//   sed 's/a/aA/g; s/__/aB/g; s/#/aC/g' "$file" | \
//     gcc -P -E $arg - | \
//     sed 's/aC/#/g; s/aB/__/g; s/aA/a/g'
// }
// 
// # this is the magic that turns multiline statements into
// # single line statements
// # LITERALLY DOES NOT WORK WITH PREPROCESSOR
// onelineize() {
//   grep -v '^#' | sed -e ':r;$!{N;br};s/\([^{;]\)\n\s*/\1 /g'
// }
// 
// discard_preprocessors() {
//   grep -v '#\(include\|if\|endif\)'
// }
// 
// # sed regex for extracting data from function signature
// # if this isn't regex, idk what is
// # LUA_API (return type as \2) (function name as \3) (args as \4)
// sym_regex='^LUA\(LIB\)\?_API\s\+\([^(]\+\)\s*(\([^)]\+\))\s\+(\([^)]\+\));'
// 
// # get funcptr declarations
// ptrize() {
//   grep '^LUA' | grep -v "$IGNORE_SYM" | sed -e "s/$sym_regex/static \2(*\3) (\4);/"
// }
// 
// import_sym() {
//   grep '^LUA' | grep -v "$IGNORE_SYM" | sed -e "s/$sym_regex/\tIMPORT_SYMBOL(\3, \2, \4);/"
// }
// 
// export_sym() {
//   grep '^LUA' | grep -v "$IGNORE_SYM" | sed -e "s/$sym_regex/\t\tEXPORT_SYMBOL(\3),/"
// }
// 
// decl() {
//   header="$(uncomment $1 | discard_preprocessors)"
//   header1="$(onelineize <<< "$header")"
// 
//   # typedef
//   grep -v '^\(LUA\|#\|extern\)' <<< "$header1"
//   # funcptrs
//   ptrize <<< "$header1"
//   # defines
//   (grep '^#' | grep -v "$IGNORE_SYM") <<< "$header"
// }
// 
// decl_import() {
//   uncomment $1 | onelineize | import_sym
// }
// 
// decl_export() {
//   uncomment $1 | onelineize | export_sym
// }
// 
// print_self() {
//   cat "$0" | sed -e 's#^#// #'
// }
// 
// generate_header() {
//   local LUA_PATH="$1"
//   echo "#ifndef LITE_XL_PLUGIN_API"
//   echo "#define LITE_XL_PLUGIN_API"
//   echo "/**"
//   echo "The lite_xl plugin API is quite simple. Any shared library can be a plugin file, so long"
//   echo "as it has an entrypoint that looks like the following, where xxxxx is the plugin name:"
//   echo '#include "lite_xl_plugin_api.h"'
//   echo "int lua_open_lite_xl_xxxxx(lua_State* L, void* XL) {"
//   echo "  lite_xl_plugin_init(XL);"
//   echo "  ..."
//   echo "  return 1;"
//   echo "}"
//   echo "In linux, to compile this file, you'd do: 'gcc -o xxxxx.so -shared xxxxx.c'. Simple!"
//   echo "Due to the way the API is structured, you *should not* link or include lua libraries."
//   echo "This file was automatically generated by the below code. DO NOT MODIFY DIRECTLY."
//   echo "**/"
//   echo
//   print_self
//   echo
//   echo "#include <stdarg.h>"
//   echo "#include <stdio.h> // for BUFSIZ? this is kinda weird"
// 
//   cat "$LUA_PATH/luaconf.h"
//   decl "$LUA_PATH/lua.h"
//   decl "$LUA_PATH/lauxlib.h"
// 
//   echo "#define IMPORT_SYMBOL(name, ret, ...) name = (ret (*) (__VA_ARGS__)) symbol(#name)"
//   echo "static void lite_xl_plugin_init(void *XL) {"
//   echo -e "\tvoid* (*symbol)(const char *) = (void* (*) (const char *)) XL;"
// 
//   decl_import "$LUA_PATH/lua.h"
//   decl_import "$LUA_PATH/lauxlib.h"
// 
//   echo "}"
//   echo "#endif"
// }
// 
// generate_api_require() {
//   local LUA_PATH="$1"
//   echo "#ifndef API_REQUIRE_H"
//   echo "#define API_REQUIRE_H"
//   echo "/**"
//   echo "This file contains the function api_require that"
//   echo "returns a function pointer with it's corresponding name."
//   echo
//   echo "This file is automatically generated. DO NOT MODIFY."
//   echo "**/"
//   echo
//   print_self
//   echo
//   echo "#include <string.h>"
//   echo "#include <stddef.h>"
//   echo '#include "lua.h"'
//   echo '#include "lauxlib.h"'
//   echo
//   echo "typedef struct fnptr_s {"
//   echo -e "\tconst char* name;"
//   echo -e "\tvoid *addr;"
//   echo "} fnptr_t;"
//   echo
//   echo "#define EXPORT_SYMBOL(SYM) { #SYM, (void*)(SYM) }"
//   echo "static void *api_require(const char *symbol) {"
//   echo -e "\tstatic fnptr_t nodes[] = {"
// 
//   decl_export "$LUA_PATH/lua.h"
//   decl_export "$LUA_PATH/lauxlib.h"
// 
//   echo -e "\t};"
//   echo -e "\tfor (int i = 0; i < sizeof(nodes) / sizeof(fnptr_t); i++)"
//   echo -e "\t\tif (strcmp(nodes[i].name, symbol) == 0)"
//   echo -e "\t\t\treturn nodes[i].addr;"
//   echo -e "\treturn NULL;"
//   echo "}"
//   echo "#endif"
// }
// 
// show_help() {
//   echo -e "Usage: $0 <OPTIONS> prefix"
//   echo
//   echo -e "Available options:"
//   echo
//   echo -e "-a\t--api-header\tGenerate lite_xl_plugin_api.h"
//   echo -e "-b\t--api-require\tGenerate api_require.h"
//   echo -e "-p\t--prefix\tSet prefix (where to find lua.h and lauxlib.h)"
// }
// 
// main() {
//   local header=0
//   local require=0
//   local prefix=""
// 
//   for i in "$@"; do
//     case $i in
//       -h|--help)
//         show_help
//         exit 0
//         ;;
//       -a|--api-header)
//         header=1
//         shift
//         ;;
//       -b|--api-require)
//         require=1
//         shift
//         ;;
//       -p|--prefix)
//         prefix="$2"
//         shift
//         shift
//         ;;
//       *)
//         ;;
//     esac
//   done
// 
//   if [[ "$header" -eq 1 ]]; then
//     generate_header "$prefix"
//   elif [[ "$require" -eq 1 ]]; then
//     generate_api_require "$prefix"
//   else
//     show_help
//     exit 1
//   fi
// }
// 
// main "$@"

#include <string.h>
#include <stddef.h>
#include "lua.h"
#include "lauxlib.h"

typedef struct fnptr_s {
	const char* name;
	void *addr;
} fnptr_t;

#define EXPORT_SYMBOL(SYM) { #SYM, (void*)(SYM) }
static void *api_require(const char *symbol) {
	static fnptr_t nodes[] = {
		EXPORT_SYMBOL(lua_newstate),
		EXPORT_SYMBOL(lua_close),
		EXPORT_SYMBOL(lua_newthread),
		EXPORT_SYMBOL(lua_atpanic),
		EXPORT_SYMBOL(lua_version),
		EXPORT_SYMBOL(lua_absindex),
		EXPORT_SYMBOL(lua_gettop),
		EXPORT_SYMBOL(lua_settop),
		EXPORT_SYMBOL(lua_pushvalue),
		EXPORT_SYMBOL(lua_remove),
		EXPORT_SYMBOL(lua_insert),
		EXPORT_SYMBOL(lua_replace),
		EXPORT_SYMBOL(lua_copy),
		EXPORT_SYMBOL(lua_checkstack),
		EXPORT_SYMBOL(lua_xmove),
		EXPORT_SYMBOL(lua_isnumber),
		EXPORT_SYMBOL(lua_isstring),
		EXPORT_SYMBOL(lua_iscfunction),
		EXPORT_SYMBOL(lua_isuserdata),
		EXPORT_SYMBOL(lua_type),
		EXPORT_SYMBOL(lua_typename),
		EXPORT_SYMBOL(lua_tonumberx),
		EXPORT_SYMBOL(lua_tointegerx),
		EXPORT_SYMBOL(lua_tounsignedx),
		EXPORT_SYMBOL(lua_toboolean),
		EXPORT_SYMBOL(lua_tolstring),
		EXPORT_SYMBOL(lua_rawlen),
		EXPORT_SYMBOL(lua_tocfunction),
		EXPORT_SYMBOL(lua_touserdata),
		EXPORT_SYMBOL(lua_tothread),
		EXPORT_SYMBOL(lua_topointer),
		EXPORT_SYMBOL(lua_arith),
		EXPORT_SYMBOL(lua_rawequal),
		EXPORT_SYMBOL(lua_compare),
		EXPORT_SYMBOL(lua_pushnil),
		EXPORT_SYMBOL(lua_pushnumber),
		EXPORT_SYMBOL(lua_pushinteger),
		EXPORT_SYMBOL(lua_pushunsigned),
		EXPORT_SYMBOL(lua_pushlstring),
		EXPORT_SYMBOL(lua_pushstring),
		EXPORT_SYMBOL(lua_pushvfstring),
		EXPORT_SYMBOL(lua_pushfstring),
		EXPORT_SYMBOL(lua_pushcclosure),
		EXPORT_SYMBOL(lua_pushboolean),
		EXPORT_SYMBOL(lua_pushlightuserdata),
		EXPORT_SYMBOL(lua_pushthread),
		EXPORT_SYMBOL(lua_getglobal),
		EXPORT_SYMBOL(lua_gettable),
		EXPORT_SYMBOL(lua_getfield),
		EXPORT_SYMBOL(lua_rawget),
		EXPORT_SYMBOL(lua_rawgeti),
		EXPORT_SYMBOL(lua_rawgetp),
		EXPORT_SYMBOL(lua_createtable),
		EXPORT_SYMBOL(lua_newuserdata),
		EXPORT_SYMBOL(lua_getmetatable),
		EXPORT_SYMBOL(lua_getuservalue),
		EXPORT_SYMBOL(lua_setglobal),
		EXPORT_SYMBOL(lua_settable),
		EXPORT_SYMBOL(lua_setfield),
		EXPORT_SYMBOL(lua_rawset),
		EXPORT_SYMBOL(lua_rawseti),
		EXPORT_SYMBOL(lua_rawsetp),
		EXPORT_SYMBOL(lua_setmetatable),
		EXPORT_SYMBOL(lua_setuservalue),
		EXPORT_SYMBOL(lua_callk),
		EXPORT_SYMBOL(lua_getctx),
		EXPORT_SYMBOL(lua_pcallk),
		EXPORT_SYMBOL(lua_load),
		EXPORT_SYMBOL(lua_dump),
		EXPORT_SYMBOL(lua_yieldk),
		EXPORT_SYMBOL(lua_resume),
		EXPORT_SYMBOL(lua_status),
		EXPORT_SYMBOL(lua_gc),
		EXPORT_SYMBOL(lua_error),
		EXPORT_SYMBOL(lua_next),
		EXPORT_SYMBOL(lua_concat),
		EXPORT_SYMBOL(lua_len),
		EXPORT_SYMBOL(lua_getallocf),
		EXPORT_SYMBOL(lua_setallocf),
		EXPORT_SYMBOL(lua_getstack),
		EXPORT_SYMBOL(lua_getinfo),
		EXPORT_SYMBOL(lua_getlocal),
		EXPORT_SYMBOL(lua_setlocal),
		EXPORT_SYMBOL(lua_getupvalue),
		EXPORT_SYMBOL(lua_setupvalue),
		EXPORT_SYMBOL(lua_upvalueid),
		EXPORT_SYMBOL(lua_upvaluejoin),
		EXPORT_SYMBOL(lua_sethook),
		EXPORT_SYMBOL(lua_gethook),
		EXPORT_SYMBOL(lua_gethookmask),
		EXPORT_SYMBOL(lua_gethookcount),
		EXPORT_SYMBOL(luaL_checkversion_),
		EXPORT_SYMBOL(luaL_getmetafield),
		EXPORT_SYMBOL(luaL_callmeta),
		EXPORT_SYMBOL(luaL_tolstring),
		EXPORT_SYMBOL(luaL_argerror),
		EXPORT_SYMBOL(luaL_checklstring),
		EXPORT_SYMBOL(luaL_optlstring),
		EXPORT_SYMBOL(luaL_checknumber),
		EXPORT_SYMBOL(luaL_optnumber),
		EXPORT_SYMBOL(luaL_checkinteger),
		EXPORT_SYMBOL(luaL_optinteger),
		EXPORT_SYMBOL(luaL_checkunsigned),
		EXPORT_SYMBOL(luaL_optunsigned),
		EXPORT_SYMBOL(luaL_checkstack),
		EXPORT_SYMBOL(luaL_checktype),
		EXPORT_SYMBOL(luaL_checkany),
		EXPORT_SYMBOL(luaL_newmetatable),
		EXPORT_SYMBOL(luaL_setmetatable),
		EXPORT_SYMBOL(luaL_testudata),
		EXPORT_SYMBOL(luaL_checkudata),
		EXPORT_SYMBOL(luaL_where),
		EXPORT_SYMBOL(luaL_error),
		EXPORT_SYMBOL(luaL_checkoption),
		EXPORT_SYMBOL(luaL_fileresult),
		EXPORT_SYMBOL(luaL_execresult),
		EXPORT_SYMBOL(luaL_ref),
		EXPORT_SYMBOL(luaL_unref),
		EXPORT_SYMBOL(luaL_loadfilex),
		EXPORT_SYMBOL(luaL_loadbufferx),
		EXPORT_SYMBOL(luaL_loadstring),
		EXPORT_SYMBOL(luaL_newstate),
		EXPORT_SYMBOL(luaL_len),
		EXPORT_SYMBOL(luaL_gsub),
		EXPORT_SYMBOL(luaL_setfuncs),
		EXPORT_SYMBOL(luaL_getsubtable),
		EXPORT_SYMBOL(luaL_traceback),
		EXPORT_SYMBOL(luaL_requiref),
		EXPORT_SYMBOL(luaL_buffinit),
		EXPORT_SYMBOL(luaL_prepbuffsize),
		EXPORT_SYMBOL(luaL_addlstring),
		EXPORT_SYMBOL(luaL_addstring),
		EXPORT_SYMBOL(luaL_addvalue),
		EXPORT_SYMBOL(luaL_pushresult),
		EXPORT_SYMBOL(luaL_pushresultsize),
		EXPORT_SYMBOL(luaL_buffinitsize),
	};
	for (int i = 0; i < sizeof(nodes) / sizeof(fnptr_t); i++)
		if (strcmp(nodes[i].name, symbol) == 0)
			return nodes[i].addr;
	return NULL;
}
#endif
